<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api/service/register.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/service/register.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import PatientModel from '../../models/patient.Model.js'
import PractitionerModel from '../../models/practitioner.Model.js'
import AdministratorModel from '../../models/administrator.Model.js'
import { whitelist_string } from '../../configure/configure.js'
import bcrypt from 'bcryptjs'
import jwt from 'jsonwebtoken'
import validator from 'validator'

const regStatus = {
	status: false,
}

/**
 * @summary Registers a new patient user with the system. All patient details need to be in the HTTP body.
 *
 * @description Function for registering a user, specifically a patient. Takes in all relevant fields from
 * the body and checks for blank, null, or undefined values. then it checks if a user with that Id
 * already exists. Assuming no issues, it creates a new patient (with a user nested inside) and returns true.
 * If any checks fail, it returns false.
 *
 * @param {request} req The HTTP request object from the route.
 * @returns {Boolean} True if success, false for failure.
 */
export const registerUser = async (req) => {
	try {
		const { genSalt, hash } = bcrypt

		// Destructure values from client request
		const {
			firstName,
			lastName,
			email,
			password,
			streetAddress,
			cityName,
			provName,
			postalCode,
			HCnumber,
			gender,
			dateOfBirth,
			phoneNumber,
			contactFirstName,
			contactLastName,
			contactPhoneNumber,
		} = req.body

		const valsFromBody = [
			firstName,
			lastName,
			email,
			password,
			streetAddress,
			cityName,
			provName,
			postalCode,
			HCnumber,
			gender,
			dateOfBirth,
			phoneNumber,
		]
		if (
			valsFromBody.includes(undefined) ||
			valsFromBody.includes(null) ||
			valsFromBody.includes('')
		) {
			return (regStatus.status = false)
		}

		//these get added here because we don't want them to be mandatory
		if (contactFirstName) valsFromBody.push(contactFirstName)
		if (contactLastName) valsFromBody.push(contactLastName)
		if (contactPhoneNumber) valsFromBody.push(contactPhoneNumber)

		//sanitize all inputs to contain only alphanumeric charcters and a few necessary punctuation marks.
		//Validator documentation at: https://github.com/validatorjs/validator.js#sanitizers
		const sanitizedVals = []
		valsFromBody.forEach((element) => {
			if (valsFromBody[2] === element || valsFromBody[3] === element) {
				sanitizedVals.push(element)
				return
			}
			if (valsFromBody[10] === element) {
				if (validator.isDate(element)) {
					sanitizedVals.push(element)
					return
				}
			}
			const sanElement = validator.whitelist(element, whitelist_string)
			sanitizedVals.push(sanElement)
		})

		// check if user exists
		const result = await PatientModel.exists({ email: sanitizedVals[2] })
		// If they exist return an error status code
		if (result?._id) {
			return (regStatus.status = false)
		}

		// Salt and Hash password
		const salt = await genSalt(10)
		const hashedPassword = await hash(sanitizedVals[3], salt)

		// verify user object
		const newUser = await PatientModel.create({
			HCnumber: sanitizedVals[8],
			gender: sanitizedVals[9],
			dateOfBirth: new Date(sanitizedVals[10]),
			email: sanitizedVals[2],
			password: hashedPassword,
			user: {
				firstName: sanitizedVals[0],
				lastName: sanitizedVals[1],
				address: {
					streetAddress: sanitizedVals[4],
					cityName: sanitizedVals[5],
					provName: sanitizedVals[6],
					postalCode: sanitizedVals[7],
				},
				phoneNumber: sanitizedVals[11],
			},
			emergencyContact: {
				firstName: sanitizedVals[12],
				lastName: sanitizedVals[13],
				phoneNumber: sanitizedVals[14],
			},
		})
		newUser.save()

		// Set Registration status and attach the user
		regStatus.status = true
		regStatus.user = newUser

		return regStatus
	} catch (error) {
		console.log(`${new Date()}n\tError:  ${error.message}`)
		return null
	}
}

/**
 * @summary A function for admins to register a new practitioner with the system. All practitioner details
 * should be in the body.
 *
 * @description Function for registering a practitioner. Takes in all relevant fields from the body and
 * checks for blank, null, or undefined values. Then it checks if a practitioner with that Id already exists.
 * Assuming no issues, it creates a new practitioner (with a user nested inside) and returns true.
 * If any checks fail, it returns false. Notably, this method can only be executed by a user who is an
 * administrator. This is ensured by checking the caller's access token, which should contain their adminId.
 * This adminId is checked against the database before the registration is allowed to proceed.
 *
 * @param {request} req An HTTP request object from the route.
 * @returns {Boolean} True for success, false for failure
 */
export const registerPractitioner = async (req) => {
	const { genSalt, hash } = bcrypt

	// Destructure values from client request
	const {
		firstName,
		lastName,
		password,
		email,
		streetAddress,
		cityName,
		provName,
		postalCode,
		practitionerId,
		role,
		phoneNumber,
		facilityId,
	} = req.body

	const adminAccessToken = req.cookies['accessTokenCookie']

	if (adminAccessToken) {
		const payload = jwt.decode(adminAccessToken)
		if (!payload) {
			console.log(
				'A non-administrator attempted to register a practitioner'
			)
			return (regStatus.status = false)
		}
		const adminId = payload.adminId
		const validAdmin = await AdministratorModel.exists({ adminId: adminId })
		if (!adminId || !validAdmin) {
			console.log(
				'A non-administrator attempted to register a practitioner'
			)
			return (regStatus.status = false)
		}
	} else {
		return (regStatus.status = false)
	}

	let valsFromBody = [
		firstName,
		lastName,
		email,
		password,
		streetAddress,
		cityName,
		provName,
		postalCode,
		practitionerId,
		role,
		phoneNumber,
	]
	if (
		valsFromBody.includes(undefined) ||
		valsFromBody.includes(null) ||
		valsFromBody.includes('')
	) {
		valsFromBody.forEach((element) => console.log(element))
		console.log('Detected a missing field in registerPractitioner')
		return (regStatus.status = false)
	}

	// check if practitioner exists
	const result = await PractitionerModel.exists({ practitionerId })
	// If they exist return an error status code
	if (result?._id) {
		return (regStatus.status = false)
	}

	// Salt and Hash password
	const salt = await genSalt(10)
	const hashedPassword = await hash(password, salt)

	// verify practitioner object
	const newPractitioner = await PractitionerModel.create({
		practitionerId: practitionerId,
		role: role,
		email: email,
		password: hashedPassword,
		user: {
			firstName: firstName,
			lastName: lastName,
			address: {
				streetAddress: streetAddress,
				cityName: cityName,
				provName: provName,
				postalCode: postalCode,
			},
			phoneNumber: phoneNumber,
		},
		facilityId: facilityId,
	})
	newPractitioner.save()

	// Set Registration status and attach the user
	regStatus.status = true
	regStatus.user = newPractitioner

	return regStatus
}

/**
 * @summary Allows an admin to register another admin. Takes all relevant fields in the body.
 *
 * @description Function for registering an administrator. Takes in all relevant fields from the body and
 * checks for blank, null, or undefined values. then it checks if an administrator with that Id already exists.
 * Assuming no issues, it creates a new administrator (with a user nested inside) and returns true.
 * If any checks fail, it returns false.
 *
 * @param {request} req A HTTP request object from the route.
 * @returns {Boolean} True for success, false for failure.
 */
export const registerAdministrator = async (req) => {
	const { genSalt, hash } = bcrypt

	// Destructure values from client request
	const {
		firstName,
		lastName,
		email,
		password,
		streetAddress,
		cityName,
		provName,
		postalCode,
		phoneNumber,
		adminId,
		permissionLevel,
	} = req.body

	let valsFromBody = [
		firstName,
		lastName,
		email,
		password,
		streetAddress,
		cityName,
		provName,
		postalCode,
		adminId,
		permissionLevel,
		phoneNumber,
	]

	if (
		valsFromBody.includes(undefined) ||
		valsFromBody.includes(null) ||
		valsFromBody.includes('')
	) {
		return (regStatus.status = false)
	}

	// check if administrator exists
	const result = await AdministratorModel.exists({ adminId: adminId })

	// If they exist return an error status code
	if (result?._id) {
		return (regStatus.status = false)
	}

	// Salt and Hash password
	const salt = await genSalt(10)
	const hashedPassword = await hash(password, salt)

	let newAdministrator
	// verify practitioner object
	try {
		newAdministrator = await AdministratorModel.create({
			adminId: adminId,
			permissions: permissionLevel,
			email: email,
			password: hashedPassword,
			user: {
				firstName: firstName,
				lastName: lastName,
				address: {
					streetAddress: streetAddress,
					cityName: cityName,
					provName: provName,
					postalCode: postalCode,
				},
				phoneNumber: phoneNumber,
			},
		})
		newAdministrator.save()
	} catch (err) {
		console.log(`${new Date()}n\tError:  ${err.message}`)
		return (regStatus.status = false)
	}

	// Set Registration status and attach the user
	regStatus.status = true
	regStatus.user = newAdministrator

	return regStatus
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="address.html">address</a></li><li><a href="administrator.html">administrator</a></li><li><a href="completedRequest.html">completedRequest</a></li><li><a href="ExpressLoader.html">ExpressLoader</a></li><li><a href="medicalFacility.html">medicalFacility</a></li><li><a href="patient.html">patient</a></li><li><a href="people.html">people</a></li><li><a href="practitioner.html">practitioner</a></li><li><a href="refresh.html">refresh</a></li><li><a href="symptom.html">symptom</a></li><li><a href="visitRequest.html">visitRequest</a></li><li><a href="vitals.html">vitals</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cancelCurrentRequest">cancelCurrentRequest</a></li><li><a href="global.html#checkAccessAuthorized">checkAccessAuthorized</a></li><li><a href="global.html#checkAccessToken">checkAccessToken</a></li><li><a href="global.html#checkAdminAlreadyLoggedIn">checkAdminAlreadyLoggedIn</a></li><li><a href="global.html#checkEmployeeAccessToken">checkEmployeeAccessToken</a></li><li><a href="global.html#checkMayAccessAdminPage">checkMayAccessAdminPage</a></li><li><a href="global.html#checkMayAccessPractitionerPage">checkMayAccessPractitionerPage</a></li><li><a href="global.html#checkPatientAlreadyLoggedIn">checkPatientAlreadyLoggedIn</a></li><li><a href="global.html#checkPractitionerAlreadyLoggedIn">checkPractitionerAlreadyLoggedIn</a></li><li><a href="global.html#completeCurrentRequest">completeCurrentRequest</a></li><li><a href="global.html#DBConnect">DBConnect</a></li><li><a href="global.html#generateAccessToken">generateAccessToken</a></li><li><a href="global.html#generateEmployeeAccessToken">generateEmployeeAccessToken</a></li><li><a href="global.html#generateEmployeeRefreshToken">generateEmployeeRefreshToken</a></li><li><a href="global.html#generateRefreshToken">generateRefreshToken</a></li><li><a href="global.html#getHospitalList">getHospitalList</a></li><li><a href="global.html#getHospitalWaitList">getHospitalWaitList</a></li><li><a href="global.html#invalidateEmployeeRefToken">invalidateEmployeeRefToken</a></li><li><a href="global.html#invalidateRefToken">invalidateRefToken</a></li><li><a href="global.html#logAdministratorIn">logAdministratorIn</a></li><li><a href="global.html#logPractitionerIn">logPractitionerIn</a></li><li><a href="global.html#logUserIn">logUserIn</a></li><li><a href="global.html#refreshAccessToken">refreshAccessToken</a></li><li><a href="global.html#refreshEmployeeAccessToken">refreshEmployeeAccessToken</a></li><li><a href="global.html#registerAdministrator">registerAdministrator</a></li><li><a href="global.html#registerPractitioner">registerPractitioner</a></li><li><a href="global.html#registerUser">registerUser</a></li><li><a href="global.html#RunApp">RunApp</a></li><li><a href="global.html#sendEmailAlt">sendEmailAlt</a></li><li><a href="global.html#updateEmployeePassword">updateEmployeePassword</a></li><li><a href="global.html#updatePassword">updatePassword</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri Apr 15 2022 16:36:02 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
